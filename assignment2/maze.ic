/*
 * maze.ic
 * Nick Rummel, Alex Medellin
 * CSC463-01
 * Fall 2017
 * Source code for Assignment 2
 * Navigating a maze with a touch sensor
 *
 * Algorithm is utilizing prediction based
 * on a history of previous turns, where:
 * -2 = strong left prediction; go left
 * -1 = weak left prediction; go left
 *  0 = no prediction; go left by default
 *  1 = weak right prediction; go right
 *  2 = strong right prediction; go right
 */

int LEFT_MOTOR = 1;                                    // port for left motor
int RIGHT_MOTOR = 3;                                   // port for right motor

int l_touch = 10;                                      // left touch sensor port
int r_touch = 11;                                      // right touch sensor port

int size = 5;                                          // number of turns stored that were
                                                       // previously taken
													   
int history[size];                                     // array of values to determine
                                                       // previous turns taken


/*
 * Function from textbook (turtle.ic)   
 * to move robot forwards
 */
void forward(float time)
{
    motor(LEFT_MOTOR, 30);
    motor(RIGHT_MOTOR, 30);
	sleep(time);
}

/*
 * Function from textbook (turtle.ic)
 * to move robot backwards
 */
void backward(float time)
{
    motor(LEFT_MOTOR, -30);
    motor(RIGHT_MOTOR, -30);
	sleep(time);
}

/*
 * Function from textbook (turtle.ic)
 * to move robot right
 */
void right(float time)
{
    motor(LEFT_MOTOR, 85);
    motor(RIGHT_MOTOR, -75);
    sleep(time);
}

/*
 * Function from textbook (turtle.ic)
 * to move robot left
 */
void left(float time)
{
    motor(LEFT_MOTOR, -75);
    motor(RIGHT_MOTOR, 85);
    sleep(time);
}

/*
 * Function from textbook (turtle.ic)
 * to stop robot from moving
 */
void stop(float time)
{
    off(LEFT_MOTOR);
    off(RIGHT_MOTOR);
    sleep(time);
}

/*
 * Initializes each index to 0,
 * meaning that there was no turn
 * recorded.
 */
void initialize_history()
{
	int i;
	for(i = 0; i < size; i++;)
		history[i] = 0;
}

/*
 * Moves the most recent history
 * record and moves it to index 0.
 * Then, all indices after 0 are
 * reset to the value 0.
 */
void reset_history()
{
	int i;
	history[0] = history[size - 1];
	for(i = 0; i < size; i++)
		history[i] = 0;
}	



void main()
{
	int i = 0;
    while(start_button());
	
	while(!stop_button())
	{
		if(digital(10) == 0 || digital(11) == 0)                        // touch sensors not pressed
			forward(0.0);
		else                                                            // touch sensors were pressed
		{
			if(i == size-1)                                             // if the history is full
			{
				reset_history();                                        // see function description
				i = 0;                                                  // set index back to 0
			}
			
			if((history[i] < 0)                                         //  prediction is left (-1 or -2)
			{
				left(1.0);
				
			}
			
			else
			{
				if((history[i]) > 0)                                    // prediction is right (1 or 2)
				{
					right(1.0);
					
				}
				else                                                    // no prediction, go left
				{
					left(1.0);
					
				}
			}
			
			
			
			i++;                                                        // only increment if a sensor was pressed
		}
		
	}
	
}