/*
 * final_project.ic
 * Nick Rummel, Alex Medellin
 * CSC463-01
 * Fall 2017
 * Source code for final project
 * Robot must navigate arena and collect
 * blocks from various points.
 */

int LEFT_MOTOR = 0;        // port for left motor
int RIGHT_MOTOR = 3;       // port for right motor
int CLAW_MOTOR = 1;        // port for claw motor
int RIGHT_IR = 4;          // analog port for the IR sensor on the right side
int LEFT_IR = 5;           // analog port for the IR sensor on the left side
int FRONT_LITE = 6;        // analog port for the photo sensor on the front
int RIGHT_LITE = 16;       // analog port for the photo sensor on the right side
int LEFT_LITE = 17;        // analog port for the photo sensor on the left side
int L_LITE_VALUE = 0;      // average value of light on left side
int R_LITE_VALUE = 0;      // average value of light on right side
int FRONT_LITE_VALUE = 0;
float last = 0.0;          // float used to determine if last move was left (-) or right (+)
int blocks[3] = {2,-3,4};   // array to keep track of the 3 block locations found in the arena
int l_power = 60;          // current power for the left motor
int r_power = 60;          // current power for the right motor
int default_power = 60;    // value that resets the motor power


/*
 * Method from textbook (turtle.ic)   
 * to move robot forwards
 */
void forward(float time)
{
    motor(LEFT_MOTOR, 60);
    motor(RIGHT_MOTOR, 60);
    sleep(time);
}

/*
 * Method from textbook (turtle.ic)
 * to move robot backwards
 */
void backward(float time)
{
    motor(LEFT_MOTOR, -60);
    motor(RIGHT_MOTOR, -60);
    sleep(time);
}

/*
 * Method from textbook (turtle.ic)
 * to move robot right
 */
void right(float time)
{
    motor(LEFT_MOTOR, 85);
    motor(RIGHT_MOTOR, -85);
    sleep(time);
}

/*
 * Method from textbook (turtle.ic)
 * to move robot left
 */
void left(float time)
{
    motor(LEFT_MOTOR, -85);
    motor(RIGHT_MOTOR, 85);
    sleep(time);
}

/*
 * Function to turn the robot
 * with a specific amount of power
 * going to each motor.
 */
void turn(int right, int left)
{
    l_power = l_power + left;
    r_power = r_power + right;
    motor(RIGHT_MOTOR, r_power);
    motor(LEFT_MOTOR, l_power);
}

/*
 * Method from textbook (turtle.ic)
 * to stop robot from moving
 */
void stop(float time)
{
    off(LEFT_MOTOR);
    off(RIGHT_MOTOR);
    sleep(time);
}

/*
 * Method to retrieve the light value
 * from the robot's photo sensor
 * and print the value to the LCD screen.
 */
int getSensorValue(int sensor_num)
{
    int value;
    value = analog(sensor_num);
    
    printf("\ns%d= %d", sensor_num, value);
    return value;
}

/*
 * The photo sensor will take in several
 * readings and compute the average of those
 * values to determine a baseline for our
 * light value range.
 */
void setLightValAvg()
{
    int i = 0;
    int sum_ir = 0;
    int sum_l = 0;
    int sum_r = 0;
    int sum_f = 0;
    while(i < 30){
        sum_l += analog(LEFT_LITE);
        sum_r += analog(RIGHT_LITE);
        sum_f += analog(FRONT_LITE);
        sleep(0.1);
        i++;
    }
    L_LITE_VALUE = sum_l/30;
    R_LITE_VALUE = sum_r/30;
    FRONT_LITE_VALUE = sum_f/30;
}

int calculateDelta()
{
    int delta = getSensorValue(RIGHT_IR) - getSensorValue(LEFT_IR);
    return delta;
}

/*
 * Takes the calculated difference
 * of the crisp input values
 * and calculates a fuzzy value.
 */
void fuzzify(int delta)
{
    float calc_val = (float)delta/255.0;
    l_power = default_power;
    r_power = default_power;
    defuzzify(calc_val);
}

/*
 * Takes the fuzzy value and maps it
 * to a crisp output value for turning.
 */
void defuzzify(float fuzz_val){
    if(fuzz_val < 0.0){
        fuzz_val = fuzz_val*100.0*4.0;
        turn(abs((int)fuzz_val), (int)fuzz_val);
        return;
    }
    if(fuzz_val > 0.0){
        fuzz_val = fuzz_val*100.0*4.0;
        turn((int)(fuzz_val*-1.0), (int)fuzz_val);
        return;
    }
    else
      turn(0, 0);
}


int abs(int value)
{
    int new = value;
    if(new < 0)
      new = new * -1;
    return new;
}

void getBlockLocations(int index, int block_loc)
{
    int new = 6 - (abs(block_loc));
    if(block_loc < 0)
      {
        new = new * -1;
    }
    blocks[index] = new;
}

int isIntersection()
{
    //printf(", inside intersection()");
    if(getSensorValue(LEFT_IR) > 160
       && getSensorValue(RIGHT_IR) > 160)
      {
        return 1;
    }
    else
      {
        return 0;
    }
}

int retrieveBlock(int loc)
{
    int sen_val = 0;
    int delta;
    forward(1.0);
    if(loc < 0)
      {
        left(1.2);
    }
    else
      {
        right(1.2);
    }
    sen_val = getSensorValue(FRONT_LITE);
    while(sen_val > 10)
      {
        delta = calculateDelta();
        fuzzify(delta);
        sen_val = getSensorValue(FRONT_LITE);
    }
    
    alloff();
    pickupBlock();
    
    backward(1.0);
    left(2.3);
    findIntersection();
    forward(1.0);
    if(loc < 0)
      {
        right(1.2);
    }
    else
      {
        left(1.2);
    }
    alloff();
}

void pickupBlock()
{
    motor(CLAW_MOTOR, 20);
    sleep(0.25);
    alloff();
}

void dropBlock()
{
    motor(CLAW_MOTOR, -15);
    sleep(0.5);
    alloff();
}

void findIntersection()
{
    int delta;
    //printf(", findIntersection()");
    while(isIntersection() == 0)
      {
        delta = calculateDelta();
        fuzzify(delta);
    }
    alloff();
    sleep(1.0);
}

int checkForAllBlocks()
{
    int i;
    for(i = 0; i < 3; i++)
      {
        if(blocks[i] == 0)
          return 0;
    }
    return 1;
}

void main()
{
    int l_side_ir = 0;
    int r_side_ir = 0;
    int l_side_lite = 0;
    int r_side_lite = 0;
    
    int state = 1;
    int cur_inter_loc = 0;
    float time = 0.0;
    
    int i = 0;
    int count, delta;
    
    while(!start_button());
    printf("\nStart!");
    setLightValAvg();                                       // calculates the baseline light average
    //front_ir = getSensorValue(FRONT_IR);                    // stores value from photo sensor
    sleep(1.0);
    
    
    while(!stop_button()){                                  // runs while we don't press the stop button
        
        // initial run to get block locations
        if(state == 0)
          {
            printf("\nState 0");
            count = 2;
            for(i = 1; i <= 5; i++)
              {
                findIntersection();
                cur_inter_loc = 6 - i;
                if(getSensorValue(LEFT_LITE) < L_LITE_VALUE - 12)
                  {
                    printf("\nFound block!");
                    getBlockLocations(count, i);
                    count--;
                }
                if(getSensorValue(RIGHT_LITE) < R_LITE_VALUE - 12)
                  {
                    getBlockLocations(count, i*-1);
                    count--;
                }
                forward(1.0);
                alloff();
                sleep(1.0);
            }
            state = 1;
            i = 0;
            
            /*if(checkForAllBlocks())
              {
                forward(1.0);
                left(2.3);
                findIntersection();
                state = 1;
            }*/
        }
        
        // find next block
        if(state == 1)
          {
            printf("\nState 1");
            
            if(abs(blocks[i]) == cur_inter_loc)
              {
                retrieveBlock(blocks[i]);
                i++;
                state = 2;
            }
            else
              {
                while(cur_inter_loc < abs(blocks[i]))
                  {
                    findIntersection();
                    forward(1.0);
                    cur_inter_loc++;
                }
                
            }
            
            // deliver block
            if(state == 2)
              {
                printf("\nState 2");
                while(cur_inter_loc > 1)
                  {
                    findIntersection();
                    cur_inter_loc--;
                    forward(1.0);
                }
                
                time = seconds() + 1.0;
                while(seconds() < time)
                  {
                    delta = calculateDelta();
                    fuzzify(delta);
                }
                alloff();
                
                dropBlock();
                
                backward(1.0);
                left(2.3);
                findIntersection();
                state = 1;
                
                // Finished collecting all 3 blocks
                if(i > 2)
                  {
                    alloff();
                    return;
                }
            }
            
        }
        printf("\nEnd!");
        alloff();
    }
}

